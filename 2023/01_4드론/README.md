# 대회 진행 전략 - 4드론(김래경, 송경준)
처음 이륙을 하면 파란색 천이 다 보이지 않아 후진을 하여 링과 파란색 천이 다 보이도록 한 후 파란색 천의 중심과 원의 중심은 같다는 것을 이용하여 드론이 링을 통과하는 방식을 사용하였다.   
     
 * 아래와 같이 사진에 링이 저런 식으로 포함될 때의
드론과의 거리와 바닥에서부터의 높이를 측정한다.
그 후 처음 링과의 거리 1m에서 드론을 이륙시키고
얼마나 뒤로 가야되는지와 얼마나 위나 아래로 움직여야되는지
인자 값을 찾아야 한다.


<img src="C:\Users\user\Desktop\img1.jpg">
<img src="C:\Users\user\Desktop\img2.jpg">

# 알고리즘 설명
     
Image  Processing Toolbox
     
MATLAB Support Package for Ryze Tello Drones 애드온 두가지 사용
## 1단계
>1. takeoff 후 링이 다 보일때까지 후진한다.
>2. 파란색 천의 중심(=원의 중심)좌표에 근사할 때 까지 움직인다.
>3. 전진하여 링을 통과한다.

## 2단계
>1. 링에서 1m정도 떨어진 위치에서 90도 우회전한다.
>2. 1단계와 동일한 방법을 사용하여 링을 통과한다.

## 3단계
>1. 링에서 1m정도 떨어진 위치에서 90도 우회전한다.
>2. 1단계와 동일한 방법을 사용하여 링을 통과한다.

## 4단계
>1. 30~60도 사이로 회전한다.
>2. 착륙지점까지 앞으로 간 후 land 한다.


# 소스 코드 설명
*  변수선언
<pre>
<code>
clear
clc

% 처음 시작할 때 뒤로 물러나는 거리
back_distance = 0.2;
% 원을 통과할 때 전진하는 거리
forward_distance = 1.8;
% 원과 드론 사이의 거리에 따라 m/pixel 값이 달라지기 때문에 
% 이것을 magic_num로 정하고 이것을 찾아야됨.
magic_num1 = 0.0025;
magic_num2 = 0.0025;
cal_z_px = 150;

count_back = 0;


centroids = [];
</code>
</pre>

* 촬영한 사진에서 파란색을 제외한 모든색을 검은색으로 변환 한다.(색 이진화)   
<pre>
<code>
function [BW,maskedRGBImage] = createMask(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 11-Jul-2023
%------------------------------------------------------


% Convert RGB image to chosen color space
I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.389;
channel1Max = 0.658;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.509;
channel2Max = 0.765;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.380;
channel3Max = 0.835;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end

</code>
</pre>
* 기기 객체선언을 한 뒤 후진을 하여 사진 촬영 및 색 이진화한 링 중심을 찾는 과정
<pre>
<code>
try
    drone = ryze()
    cam = camera(drone);

    takeoff(drone);
    pause(1);
    moveup(drone, 'Distance', 0.8)
    moveback(drone, 'Distance', 1.4, 'Speed', 0.4);
    
    % pause(1)

    % stage 1
    while 1
        % moveback(drone, 'Distance', back_distance, 'Speed', 0.4);
        
        pause(1);
        frame = snapshot(cam);
        preview(cam)
        pause(1);

        [height, width, channel] = size(frame);
        
        [BW,maskedRGBImage] = createMask(frame);
        figure(1)
        imshow(BW)
        
        edge_BW1 = edge(BW, 'Sobel', 'vertical'); 
        edge_BW2 = edge(BW, 'Sobel', 'horizontal');
        edge_BW = (edge_BW1 + edge_BW2);
        fill_im = imfill(edge_BW,'holes');
        boundaries = bwboundaries(fill_im);
         
        stats = regionprops(fill_im, 'Centroid', 'Circularity');
        centroids = cat(1, stats.Centroid);
        figure(2)
        imshow(frame)
        hold on
        plot(centroids(:,1),centroids(:,2),'b*')
        
        % while 문 종료 조건
        if 410 < centroids(1, 1) && 530 > centroids(1, 1)
            if 110 <centroids(1, 2) && 190 > centroids(1, 2)
                break
            end
        end 
</code>
</pre>

* 원의 중심 픽셀 좌표 값을 미터 단위로 변형 후 원의 중심좌표로 근사할때까지 드론을 이동 후 전진하여 링 통과 한 뒤 90도 회전
<pre>
<code>
 if isempty(centroids) == true
            count_back = count_back + 1;
            continue
        end
        coord_x = (centroids(1, 1)-width/2)*magic_num1;
        coord_y = (cal_z_px-centroids(1, 2))*magic_num2;
        abs_coord_x = abs(coord_x(1))
        abs_coord_y = abs(coord_y(1))

        if abs_coord_x < 0.2 || abs_coord_x > 5
           coord_x(1) = 0.2
        end
        if abs_coord_y < 0.2 || abs_coord_y > 5
           coord_y(1) = 0.2
        end
        
        move(drone,[0 coord_x(1) -coord_y(1)/2])
        pause(3)
 % stage1 => 2
    moveforward(drone, 'Distance', forward_distance + count_back * back_distance);
    turn(drone, rad2deg(90))


        

    end
</code>
</pre>

* 2,3단계에서도 1단계의 방식을 사용한다.


* 4단계에서는 45도 회전 후 2m 전진 한 뒤에 착륙 한다.
<pre>
<code>
turn(drone, rad2deg(45))
    moveforward(drone, 'Distance', 2);
    land(drone)
</code>
</pre>


