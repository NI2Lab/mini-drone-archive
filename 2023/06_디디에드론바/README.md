
# 디디에 드론바(이현수, 조선민)

<img src=C:\Users\user\Desktop\드론바.jpg>

# 대회 진행 전략
<img src="C:\Users\user\Desktop\맵상세.png">

우선 맵 상세도를 보게되면 출발지점과 링의 거리가 1m 인 것을 알 수 있다. 출발지점에서 바로 이륙을 하면 파란색 천이 전체적으로 보이지 않기 때문에 이륙 후후 파란색 천이 다 보일 수 있도록 후진을 한다 후진을 하고 링과 파란색 천이 다 보이면 원의 중심이 천의 중심에 있다는 것을 알기 때문에 사각형의 중심을 찾아서 드론이 링을 통과하는 방식을 사용하였다.   
     




# 알고리즘 설명
-사용한 Toolbox (2가지)    
*Image  Processing Toolbox
     
*MATLAB Support Package for Ryze Tello 

## 1단계
>1. drone ryze 함수를 사용하여연결
>2. 이륙 후 크로마키가 다 보일때까지 후진한다.
>3. 높이를 중심으로 최대한 맞추기 위해 높이를 살짝 올린다.
>4. 파란색 크로마키의 중심 좌표에 근사할 때 까지 움직인다.
>5. 전진하여 링을 통과한다.

## 2단계
>1. 링에서 1m정도 떨어진 위치에서 90도 우회전한다.
>2. 1단계에서 같은 방법으로 크로마키의 중심을 찾는다.
>3.전진하여 링을 통과한다.

## 3단계
>1. 링에서 1m정도 떨어진 위치에서 90도 우회전한다.
>2. 1단계에서 같은 방법으로 크로마키의 중심을 찾는다.
>3.전진하여 링을 통과한다.

## 4단계
>1. 30~60도 사이인 각도로 회전한다.
>2. 크로마키의 중심을 찾는다.
>3. 착륙지점까지 앞으로 간 후 land 한다.


# 소스 코드 설명
*  함수 지정
<pre>
<code>
clear
clc

% 처음 시작할 때 뒤로 물러나는 거리
back_distance = 1;
% 원을 통과할 때 전진하는 거리
forward_distance = 3;
% 원과 드론 사이의 거리에 따라 m/pixel 값이 달라지기 때문에 
% 이것을 magic_num로 정하고 이것을 찾아야됨.
magic_num1 = 0.0025;
magic_num2 = 0.0025;
cal_z_px = 150;

count_back = 0;


centroids = [];
</code>
</pre>

* 파란색과 검은색 두 가지 색상으로 구분(색 이진화)   
<pre>
<code>
function [BW,maskedRGBImage] = createMask(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 11-Jul-2023
%------------------------------------------------------


% Convert RGB image to chosen color space
I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.389;
channel1Max = 0.658;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.509;
channel2Max = 0.765;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.380;
channel3Max = 0.835;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end

</code>
</pre>
* 객체선언 후 후진을 하여 사진 촬영 및 색 이진화한 링 중심을 찾는 과정
<pre>
<code>
try
    drone = ryze()
    cam = camera(drone);

    takeoff(drone);
    pause(1);
    moveup(drone, 'Distance', 0.7)
    moveback(drone, 'Distance', 1.4, 'Speed', 0.4);
    
    % pause(1)

    % stage 1
    while 1
        % moveback(drone, 'Distance', back_distance, 'Speed', 0.4);
        
        pause(1);
        frame = snapshot(cam);
        preview(cam)
        pause(1);

        [height, width, channel] = size(frame);
        
        [BW,maskedRGBImage] = createMask(frame);
        figure(1)
        imshow(BW)
        
        edge_BW1 = edge(BW, 'Sobel', 'vertical'); 
        edge_BW2 = edge(BW, 'Sobel', 'horizontal');
        edge_BW = (edge_BW1 + edge_BW2);
        fill_im = imfill(edge_BW,'holes');
        boundaries = bwboundaries(fill_im);
         
        stats = regionprops(fill_im, 'Centroid', 'Circularity');
        centroids = cat(1, stats.Centroid);
        figure(2)
        imshow(frame)
        hold on
        plot(centroids(:,1),centroids(:,2),'b*')
        
        % while 문 종료 조건
        if 410 < centroids(1, 1) && 530 > centroids(1, 1)
            if 110 <centroids(1, 2) && 190 > centroids(1, 2)
                break
            end
        end 
</code>
</pre>

* 원의 중심 픽셀 좌표 값을 미터 단위로 변형 후 원의 중심좌표로 근사할때까지 드론을 이동 후 전진하여 링 통과 한 뒤 90도 회전
<pre>
<code>
 if isempty(centroids) == true
            continue
        end
        coord_x = (centroids(1, 1)-width/2)*magic_num1;
        coord_y = (cal_z_px-centroids(1, 2))*magic_num2;
        abs_coord_x = abs(coord_x(1));
        abs_coord_y = abs(coord_y(1));

        if abs_coord_x < 0.2 || abs_coord_x > 5
           coord_x(1) = 0.2;
        end
        if abs_coord_y < 0.2 || abs_coord_y > 5
           coord_y(1) = 0.2;
        end
        
        move(drone,[0 coord_x(1) -coord_y(1)/2])
        pause(1)      
    end

    % stage1 => 2

    disp("forward")
    moveforward(drone, 'Distance', forward_distance + 0.5);
    disp("turn 90")
    turn(drone, deg2rad(90))

    disp("stage1 end")
    moveback(drone, 'Distance', back_distance);
    
    disp("stage2 start")


        

    end
</code>
</pre>

* 2,3단계에서도 1단계의 방식을 사용한다.
 % stage2
    count = 0;
    while 1
        frame = snapshot(cam);
        preview(cam)
        pause(1);

        count = count + 1;
        fprintf("count is %d", count)

        [height, width, channel] = size(frame);
        
        [BW,maskedRGBImage] = createMask(frame);
        
        edge_BW1 = edge(BW, 'Sobel', 'vertical'); 
        edge_BW2 = edge(BW, 'Sobel', 'horizontal');
        edge_BW = (edge_BW1 + edge_BW2);
        fill_im = imfill(edge_BW,'holes');
        boundaries = bwboundaries(fill_im);
         
        stats = regionprops(fill_im, 'Centroid', 'Circularity');
        centroids = cat(1, stats.Centroid);
        figure(1)
        imshow(frame)
        hold on
        plot(centroids(:,1),centroids(:,2),'b*')
        fprintf("x is %d and y is %d", centroids(1,1), centroids(1,2))
        
        % while 문 종료 조건
        if 410 < centroids(1, 1) && 530 > centroids(1, 1)
            if 110 <centroids(1, 2) && 190 > centroids(1, 2)
                disp("stage 2 break")
                break
            end
        end
        if count == 3
            disp("stage 2 count break")
            break
        end 
        
        if isempty(centroids) == true
            continue
        end
        coord_x = (centroids(1, 1)-width/2)*magic_num1;
        coord_y = (cal_z_px-centroids(1, 2))*magic_num2;
        abs_coord_x = abs(coord_x(1));
        abs_coord_y = abs(coord_y(1));

        if abs_coord_x < 0.2 || abs_coord_x > 5
           coord_x(1) = 0.2;
        end
        if abs_coord_y < 0.2 || abs_coord_y > 5
           coord_y(1) = 0.2;
        end
        
        move(drone,[0 coord_x(1) -coord_y(1)/2])
        pause(1)      
    end

    % stage2 => 3
    disp("forward")
    moveforward(drone, 'Distance', forward_distance + 0.5);
    disp("turn 90")
    turn(drone, deg2rad(90))

    moveback(drone, 'Distance', back_distance);
    count = 0;
    % stage3
    while 1
        frame = snapshot(cam);
        preview(cam)
        pause(1);

        count = count + 1;

        [height, width, channel] = size(frame);
        
        [BW,maskedRGBImage] = createMask(frame);
        
        edge_BW1 = edge(BW, 'Sobel', 'vertical'); 
        edge_BW2 = edge(BW, 'Sobel', 'horizontal');
        edge_BW = (edge_BW1 + edge_BW2);
        fill_im = imfill(edge_BW,'holes');
        boundaries = bwboundaries(fill_im);
         
        stats = regionprops(fill_im, 'Centroid', 'Circularity');
        centroids = cat(1, stats.Centroid);
        figure(1)
        imshow(frame)
        hold on
        plot(centroids(:,1),centroids(:,2),'b*')
        
        % while 문 종료 조건
        if 410 < centroids(1, 1) && 530 > centroids(1, 1)
            if 110 <centroids(1, 2) && 190 > centroids(1, 2)
                disp("stage 3 break")
                break
            end
        end
        if count == 5
            break
        end 
        
        if isempty(centroids) == true
            continue
        end
        coord_x = (centroids(1, 1)-width/2)*magic_num1;
        coord_y = (cal_z_px-centroids(1, 2))*magic_num2;
        abs_coord_x = abs(coord_x(1));
        abs_coord_y = abs(coord_y(1));

        if abs_coord_x < 0.2 || abs_coord_x > 5
           coord_x(1) = 0.2;
        end
        if abs_coord_y < 0.2 || abs_coord_y > 5
           coord_y(1) = 0.2;
        end
        
        move(drone,[0 coord_x(1) -coord_y(1)/2])
        pause(1)      
    end
    moveforward(drone, 'Distance', forward_distance + 1.0);
  
    
catch error
    disp(error);
    clear;

end


* 4단계에서는 45도 회전 후 2m 전진 한 뒤에 착륙 한다.
<pre>
<code>
  % 대략 45도 회전해서 2m 전진 후 착륙
    turn(drone, deg2rad(45))
    moveforward(drone, 'Distance', forward_distance);
    land(drone)


