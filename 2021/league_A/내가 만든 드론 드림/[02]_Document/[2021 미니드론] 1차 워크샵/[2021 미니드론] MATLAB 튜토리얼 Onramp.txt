# 2.1장 명령 입력하기
1) 명령 3*5를 입력하여 숫자 3과 5를 곱하세요.
3 * 5

2) 다음과 같이 입력하여 변수 m에 3*5 계산 결과를 할당하세요.
m = 3*5

3) 명령 m = m + 1을 입력하여 어떤 동작이 발생하는지 확인하세요.
m = m + 1

4) 값이 m/2인 변수 y를 만드세요.
y = m / 2

5) k = 8 - 2;을 입력하여 명령 맨 끝에 세미콜론을 추가하세요.
명령 창에는 실행 결과가 표시되지 않지만 작업 공간 창에서 해당 값을 확인할 수 있습니다.
k = 8 - 2;

6) 위쪽 화살표 키를 눌러 명령 m = 3*5를 되돌아간 다음
이 명령을 편집하여 m = 3*k로 수정하세요.
m = 3 * k

7) 앞부분에서 m을 사용하여 y의 값을 계산했습니다. m이 수정되었을 때 y도 다시 계산되었을까요?
명령 창에 변수 이름 y만 입력하고 Enter 키를 눌러 보세요.
y

추가실습) MATLAB은 명령 창에 있는 이전 명령을 다시 실행하지 않기 때문에 y의 값이 변경되지 않았습니다. m이 수정된 후 y를 다시 계산하려면 명령 y = m/2를 다시 실행해야 합니다.
지금 다시 한 번 해 보세요. 위쪽 화살표 키를 사용하여 명령 y = m/2를 다시 불러온 다음
Enter 키를 누르세요. y의 새 값을 표시하려면 명령의 맨 끝에 세미콜론을 사용하지 않아야 합니다.
y = m / 2

--------------------------------------------------------------------------------------------------------------------
# 2.2장 변수 이름 지정하기
1) 값 -2를 변수 A에 할당하세요.
A = -2

2) a+A / 2를 계산하세요. 그 결과를 변수 avgAa에 할당하세요.
avgAa = (a + A) / 2

추가실습) 유효하지 않은 변수 이름을 사용하면 MATLAB에서 정정 사항을 제안합니다.
제안된 명령을 그대로 사용하거나 수정할 수 있으며, Esc 키를 눌러 이 제안을 삭제할 수 있습니다.
변수 3sq = 9를 만들어 이 동작을 직접 확인해 보세요.
3sq = 9
>> sq = 9

--------------------------------------------------------------------------------------------------------------------
# 2.3 변수 저장 및 불러오기
1) 작업 공간의 변수를 datafile.mat라는 파일로 저장하세요.
save datafile

2)clear를 사용하여 작업 공간을 비우세요.
clear

3)파일 datafile.mat로부터 변수를 불러오세요.
load datafile

4)변수 data의 내용을 표시하세요.
data

5)clc 명령을 사용하여 명령 창의 내용을 지우세요.
clc

추가실습)일부 변수만 불러오거나 저장하려면 함수에 두 개의 입력값을 사용하면 됩니다. 파일 myData.mat로부터 변수 m만 불러와 보세요.
load myData m
그런 다음 변수 m을 justm.mat라는 새 MAT 파일로 저장해 보세요.
save justm m

--------------------------------------------------------------------------------------------------------------------
# 2.4 내장 함수와 상수 사용하기
1) 값이 π/2인 변수 x를 만드세요.
x = pi/2

2) sin 함수를 사용하여 x의 사인을 계산하세요. 그 결과를 변수 y에 할당하세요.
y = sin(x)

3) sqrt 함수를 사용하여 -9의 제곱근을 계산하세요. 그 결과를 변수 z에 할당하세요.
z = sqrt(-9)

추가실습) 참고로 계산된 해에 허수 i가 포함된 것을 볼 수 있습니다. 이는 MATLAB에 내장된 상수입니다.

명령 창에는 소수점 이하 네 자릿수까지만 표시됩니다. format 함수를 사용하여 표시되는 정밀도를 제어할 수 있습니다.

format long을 입력하고 x의 값을 표시해 보세요. 디폴트 표시로 되돌리려면

format short를 입력합니다.

--------------------------------------------------------------------------------------------------------------------
# 3.2 MATLAB 편집기
1) 스크립트에서 명령 r = 3을 입력하세요.
r = 3

2) 명령 x = pi*r^2을 스크립트에 추가하세요.
r = 3
x = pi*r^2

추가실습) 라이브 편집기에서 작업을 완료하면 명령 창 및 작업 공간이 최소화됩니다.

명령 창과 작업 공간은 이름을 클릭하면 여전히 액세스할 수 있습니다.

오른쪽에 있는 작업 공간을 클릭하여 작업 공간에서 변수 x 및 r을 확인해 보세요.

--------------------------------------------------------------------------------------------------------------------
# 3.3 스크립트 실행하기
1) 스크립트를 실행하면 출력 창이 출력값으로 채워집니다.

그런 후 r의 값이 0.5가 되도록 Task 1에 대한 명령을 수정하세요.

r = 0.5

추가실습) 한 섹션에 대한 코드만 실행하려면 MATLAB 툴스트립에서 섹션 실행 버튼을 클릭하면 됩니다.

r의 값을 변경하고 오직 해당 섹션만 실행해 보세요. 그 결과, 출력 창에서 r의 값이 어떻게 되나요? 그리고 x의 값은 어떻게 되나요?

툴스트립의 버튼을 사용하여 새 섹션을 만들 수도 있습니다. y = 2*pi*r을 포함하는 새 섹션을 만들어 보세요.

y = 2*pi*r

--------------------------------------------------------------------------------------------------------------------
# 4.1 직접 입력하여 배열 만들기
1) 값이 4인 변수 x를 만드세요.
x = 4

2) 2개의 요소, 7과 9를 갖는 배열 x를 만드세요.
x = [7 9]

3) 한 열에 2개의 요소, 7과 9를 갖는 배열 x를 만드세요.
이전 작업의 명령을 복사한 후, 숫자 사이의 공백을 세미콜론(;)으로 바꿔 보세요.
x = [7;9]

4) 값 3, 10, 5의 순서로 요소를 포함하는 행 벡터 x를 만드세요.
x = [3 10 5]

5) 값 8, 2, -4의 순서로 요소를 포함하는 열 벡터 x를 만드세요.
x = [8;2;-4]

6) 아래에 보이는 값을 갖는 행렬 x를 만드세요.
5    6    7
8    9   10

x = [5 6 7;8 9 10]

7) sqrt(10)을 첫 번째 요소로, pi^2(π^2)을 두 번째 요소로 갖는 행 벡터 x를 만드세요.
x = [sqrt(10) pi^2]

추가실습) 공백, 쉼표 및 세미콜론 등을 사용해 다음 행렬을 만들어 보세요.
7	1	8
4	5	8
10	4	2

x = [7 1 8;4 5 8;10 4 2]
x=[7 1 8;4 5 8;10 4 2]
x = [7, 1, 8;4, 5, 8;10, 4, 2]

--------------------------------------------------------------------------------------------------------------------
# 4.2 요소 간 간격이 균일한 벡터 만들기
1) 값 1, 2, 3의 순서로 요소를 포함하는 행 벡터 변수 x를 만드세요.
x = [1 2 3]

2) 값 1, 2, 3, 4의 순서로 요소를 포함하는 행 백터 변수 x를 만들되, 이번에는 : 연산자를 사용하세요.
x = 1:4

3) 1에서 시작해 5에서 끝나며, 요소 간 간격이 0.5인 행 벡터 x를 만드세요.
x = 1:0.5:5

4) 3에서 시작해 13에서 끝나며, 요소 간 간격이 2인 행 벡터 x를 만드세요.
x = 3:2:13

5) 1에서 시작해 10에서 끝나며, 요소의 개수가 5개인 행 벡터 x를 만드세요.
x = linspace(1,10,5)

6) 전치 연산자를 사용하여 x를 행 벡터에서 열 벡터로 전치하세요.
x = x'

7) 한 번의 명령으로 5에서 시작해 9에서 끝나며, 요소 간 간격이 2인 열 벡터 x를 만드세요.
x = (5:2:9)'

추가실습) linspace 또는 :을 사용하여 벡터를 만드는 경우 대괄호([])를 사용할 필요가 없습니다.
1에서 2π까지 균일한 간격의 요소 100개로 구성된 벡터를 만들어야 할 경우 linspace 또는 : 중 어느 방법을 사용하시겠습니까?

x = linspace(1,2*pi,100)

--------------------------------------------------------------------------------------------------------------------
# 4.3 배열 생성 함수
1)난수로 구성된 5x5 행렬인 변수 x를 만드세요.
x = rand(5)

2) rand를 사용하여 5개의 행과 1개의 열로 구성된 배열을 만들고 그 결과를 변수 x에 할당하세요.
x = rand(5, 1)

3) zeros 함수를 사용하여 6개 행과 3개 열을 가지며, 요소가 모두 0인 행렬(6x3)을 만들고 그 결과를 변수 x에 할당하세요.
x = zeros(6, 3)

추가실습) 기존 행렬의 크기는 어떻게 확인할 수 있을까요? size 함수를 사용하면 됩니다.
size(x)

또한, 코드 한 줄로 기존 행렬과 동일한 크기의 행렬을 만들 수도 있습니다.
rand(size(x))

--------------------------------------------------------------------------------------------------------------------
# 5.1 배열의 요소 참조하기
1) 변수 data의 6번째 행, 3번째 열의 값을 갖는 변수 x를 만드세요.
x = data(6,3)

2) end 키워드를 사용하여 변수 data의 마지막 행, 3번째 열의 값을 구하고 이 값을 변수 x에 할당하세요.
x = data(end, 3)

3) data의 마지막에서 두 번째(end-1) 행, 3번째 열의 값을 포함하는 스칼라 변수 x를 만드세요.
x = data(end-1, 3)

추가실습) 한 행렬에 대해 하나의 인덱스만 사용할 경우 각각의 열을 순서대로 아래 방향으로 순회하게 됩니다. 
하나의 인덱스를 사용하여 데이터의 8번째 요소를 추출해 보세요.
또한, 변수를 인덱스로 사용할 수도 있습니다. 변수 y를 만들고 y를 data에 대한 인덱스로 사용해 보세요.

y = data(8)

--------------------------------------------------------------------------------------------------------------------
# 5.2 여러 개의 요소 추출하기
1) 행렬 data의 두 번째 열을 포함하는 변수 density를 만드세요.
density = data(:,2)

2) data의 마지막 두 개 열을 포함하는 변수 volumes를 만드세요.
volumes = data(:, end-1:end)

3) 단일 인덱스 값을 사용하여 벡터 density의 6번째 요소를 포함하는 변수 p를 만드세요.
p = density(6)

4) 특정 범위의 인덱스 값을 사용하여 density의 2번째 요소부터 5번째 요소까지를 포함하는 변수 p를 만드세요.
p = density(2:5)

추가실습) 인덱스는 연속되지 않은 숫자를 사용해도 됩니다. density의 첫 번째 요소, 세 번째 요소 및 여섯 번째 요소를 추출해 보세요.
density(1:2:6)

--------------------------------------------------------------------------------------------------------------------
# 5.3 배열의 값 변경하기
1) data의 마지막 열을 포함하는 벡터 v2를 만드세요.
v2 = data(:,end)

2) v2의 첫 번째 요소를 NaN에서 0.5로 변경하세요.
v2(1) = 0.5

3) data의 첫 번째 행, 마지막 열의 요소 값을 0.5로 변경하세요.
data(1,end) = 0.5

추가실습) data의 첫 번째 열을 data의 두 번째 열로 변경해 보세요.
data(:,1) = data(:,2)

--------------------------------------------------------------------------------------------------------------------
# 6.1 벡터에 대한 배열 연산 수행하기
1) v1의 각 요소에 1을 더하고 그 결과를 변수 r에 저장하세요.
r = v1 + 1

2) 벡터 v1 및 벡터 v2의 합인 벡터 vs를 만드세요.
vs = v1 + v2

3) 값 vs를 2로 나눈 값(평균 부피)을 포함하는 변수 va를 만드세요.
va = vs/2

4) va 벡터의 최댓값을 포함하는 변수 vm을 만드세요.
vm = max(va)

5) round 함수를 사용하여 반올림된 평균 부피 va를 포함하는 변수 vr을 만드세요.
vr = round(va)

6) density와 va에 대해 요소별 곱셈 연산을 수행하고 그 결과를 변수 mass에 저장하세요.
mass = density .* va

추가실습) x = [1 2;3 4;5 6; 7 8].*[1;2;3;4]
x의 크기는 무엇이 될까요?
x = 4x2

==================================================================
# 7.1장 함수에서 여러 개의 출력값 구하기
1) data 변수의 크기를 포함하는 변수 dsize를 만드세요.
dsize = size(data)

2) 변수 data의 행 개수와 열 개수를 각각 포함하는 변수 dr 및 dc를 만드세요.
[dr, dc] = size(data)

3) v2 벡터의 최댓값과 이에 해당하는 인덱스 값을 각각 포함하는 변수 vMax 및 ivMax를 만드세요.
[vMax, ivMax] = max(v2)

추가학습) v2에서 최솟값의 인덱스 값을 구해 보세요. 이 인덱스를 사용하여 density에서 값을 추출해 보세요.
density = v2
[~, ivMin] = min(v2)
density(ivMin)

==================================================================
# 8.1장 도움말 보기(실습)
1) randi에 대한 도움말 문서를 참조하여 아래 작업을 완료하세요.
    다음과 같은 행렬 x를 만드세요.
    1부터 20까지의 임의의 정수를 포함함
    5개 행을 가짐
    7개 열을 가짐
x = randi(20, 5, 7)

추가실습) 또한, doc 함수를 사용하여 도움말 문서를 열 수도 있습니다.
아래 코드를 사용하여 randi에 대한 도움말 문서를 열어 보세요.
doc 정규분포된 난수
randn(5, 7)

==================================================================
# 9.1장 벡터 플로팅
1) x축이 sample이고 y축이 mass1인 플롯을 생성하세요.
plot(sample, mass1)

2) sample(x축)에 대해 mass2(y축)를 플로팅하세요.
이때 플롯에 선은 그리지 않고 빨간색(r) 별 마커(*)만 표시되도록 하세요.
plot(sample, mass2, "r*")

3) hold on 명령을 입력하세요.
그런 다음 sample(x축)에 대해 mass1(y축)을 플로팅하세요.
이때 선은 그리지 않고 검은색(k) 정사각형 마커(s)만 표시되도록 하세요.
hold on
plot(sample, mass1, "ks")

4) hold off 명령을 입력하세요.
hold off

5) 아래 명령을 사용하여 벡터 v1을 플로팅하세요.
plot(v1)

6) 선 너비를 3으로 지정하여 v1을 플로팅하세요.
plot(v1, "LineWidth", 3)

7) sample(x축)에 대해 v1(y축)을 플로팅하세요.
선 너비를 4로 지정하고 빨간색(r) 원 마커(o)를 사용하세요.
plot(sample, v1, "ro", "LineWidth", 4)

8) histogram 함수를 사용하여 density의 히스토그램을 생성해 보세요.
"FaceColor"를 노란색("y")으로 설정하세요.
histogram(density,"FaceColor","y")	% 확실하지 않음

--------------------------------------------------------------------------------------------------------------------
# 9.2장 플롯에 주석 달기
1) 플롯에 "Sample Mass"라는 제목을 추가하세요.
title("Sample Mass")

2) ylabel 함수를 사용하여 "Mass (g)"라는 레이블을 추가하세요.
ylabel("Mass (g)")

3) 레이블 "Exp A" 및 "Exp B"를 차례로 지정하여 범례를 만드세요.
legend("Exp A", "Exp B")

추가실습) 플롯에 주석을 달 때 문자열과 변수를 결합하면 변수의 값을 사용할 수 있습니다.
bar(data(3,:))
title("Sample " + sample(3) + " Data")

==================================================================
# 10.1장 프로젝트 - 전력 사용량
이 프로젝트에서는 다양한 경제 부문(주거, 상업 및 공업)의 전력 사용량을 플로팅해 봅니다. 어느 경제 부문의 사용량이 가장 클 것으로 생각하시나요?
이 프로젝트에서는 매년 7월에 수집된 미국의 전력 사용량 데이터를 사용합니다. 사용량 데이터의 단위는 109kWh/day이며, 가격 데이터의 단위는 US cents/kWh입니다.

1) 전력 데이터가 electricity.mat 파일에 저장되어 있습니다. MAT 파일을 MATLAB으로 불러오세요.
그런 다음 스크립트에 usage를 입력하여 행렬을 표시하세요.
load electricity
usage

2) usage 변수에 포함된 요소 중 하나의 값이 NaN입니다. 이 값을 값 2.74로 바꾸세요.
usage(2, 3) = 2.74

3) 주거 데이터가 첫 번째 열에 저장되어 있습니다.
usage의 첫 번째 열을 포함하는 변수 res를 만드세요.
res = usage(:, 1)

4) 상업 데이터와 공업 데이터가 두 번째 열과 세 번째 열에 각각 저장되어 있습니다.
usage의 두 번째 열과 세 번째 열을 포함하는 변수 comm과 ind를 만드세요.
comm = usage(:, 2)
ind = usage(:, 3)

5) 1991년부터 2013년까지의 연도를 나타내는 벡터 yrs를 만드세요.
yrs = (1991:2013)

6) 세 열에 대한 플롯을 만드세요. yrs를 x 데이터로 사용하고 다음 플롯 사양을 순서대로 사용하세요.
res: 파란색(b) 파선(--)
comm: 검은색(k) 점선(:)
ind: 자홍색(m) 일점 쇄선(-.)

hold on
plot(yrs, res, "b--")
plot(yrs, comm, "k:")
plot(yrs, ind, "m-.")

7) "July Electricity Usage"라는 제목을 기존 플롯에 추가하세요.
값 "res", "comm", "ind"를 범례로 만드세요.
title("July Electricity Usage")
legend("res", "comm", "ind")

추가실습) Figure를 살펴보면 공업 부문의 전력 사용량이 꽤 일관되며
거주 및 상업 부문에 비해 변동이 크지 않다는 것을 알 수 있습니다.
-> 그냥 plot 결과를 보고 분석한 것임, 별도의 코드는 없음

--------------------------------------------------------------------------------------------------------------------
# 10.2장 프로젝트 - 오디오 주파수
오디오 신호는 일반적으로 서로 다른 여러 주파수로 구성됩니다.
예를 들어, 음악에서 '가온다(middle C)' 음의 기본 주파수는 261.6Hz이며,
대부분의 음악은 동시에 연주되는 여러 음 즉, 주파수로 구성됩니다.

이 프로젝트에서는 C 코드를 연주하는 오르간의 주파수 성분을 분석해 봅니다.
C 코드는 C(261.6Hz), E(329.6Hz), G(392.0Hz)로 구성됩니다.
주파수 플롯에서 강조 표시된 점은 각 음에 해당합니다.

1) 파일 Cchord.mat를 불러오세요. y에 포함된 요소의 개수를 나타내는 변수 n을 만드세요.
그런 다음 n을 사용하여 0에서 n-1까지 요소 간격이 1인 벡터 t를 만드세요.
load Cchord
n = numel(y)
t = (0:n-1)

2) t를 fs로 나누고 해당 출력값을 다시 t에 할당하세요. 그런 다음 t에 대해 y를 플로팅하세요.
t = t / fs
plot(t, y)

3) y의 이산 푸리에 변환에 대한 절댓값을 포함하는 변수 yfft를 만드세요.
yfft = abs(fft(y))

4) 0에서 n-1까지 요소 간격이 1인 벡터 f를 만드세요.
f = (0:n-1)

5) f를 fs/n와 곱하고 그 출력값을 다시 f에 할당하세요.
x축 제한으로 0~1000을 지정하여 f에 대해 yfft를 플로팅하세요.
f = f * fs / n
plot(f, yfft)
xlim([0 1000])

추가실습) 출력 창에서 데이터 커서를 사용하여 주파수 위치를 확인하세요.
-> 플롯창에 마우스커서를 댄 후 "데이터 팁" 도구를 클릭한 다음 그래프를 클릭

==================================================================
# 11.1장 가져오기 툴
1) elements.Density의 내용을 열 벡터 d에 할당하세요.
d = elements.Density

2) elements.Density의 각 요소를 elements.Volume1과 곱하세요. .*를 사용해야 합니다.
결과를 elements.Mass에 할당하세요.
elements.Mass = elements.Density .* elements.Volume1

3) 가장 작은 질량부터 가장 큰 질량 순으로 테이블을 정렬하세요.
그런 다음, 스크립트에서 코드를 업데이트하고 제출하기를 클릭하세요.
-> 출력창에서 기준열 클릭 - 아래삼각형 클릭 - 오름차순 정렬 - 코드 업데이트 클릭

4) 다음을 실행하여 테이블의 처음 3개 행을 추출해 보세요.
top3도 테이블임을 확인할 수 있습니다.
top3 = elements(1:3,:)

==================================================================
# 12.1장 논리형 인덱싱
1) 관계 연산자 <을 사용하여 π가 4보다 작은지 테스트하세요. 그 출력값을 변수 test에 할당하세요.
test = pi < 4

2) 벡터 v1의 요소가 4보다 작은지 테스트하세요. 그 출력값을 변수 test에 할당하세요.
test = v1 < 4

3) 4보다 작은 v1의 요소를 모두 포함하는 변수 v를 만드세요.
v = v1(v1 < 4)

4) 4보다 작은 v1의 요소들과 같은 위치에 있는 sample의 요소들을 포함하는 변수 s를 만드세요.
s = sample(v1 < 4)

5) 4보다 작은 모든 값이 값 0으로 대체되도록 v1을 수정하세요.
v1(v1 < 4) = 0

추가실습) 논리 연산자 and(&) 및 or(|)을 사용하여 여러 논리 비교를 결합할 수 있습니다.
4보다 작고 그리고 2보다 큰 값을 찾으려면 &를 사용하세요.
-> x = v1(v1<4 & v1>2)
6보다 크거나 또는 2보다 작은 값을 찾으려면 |을 사용하세요.
-> x = v1(v1>6 | v1<2)
sample에서 10과 20 사이의 값을 구해 보세요.
-> x = sample(10 <= sample & sample <= 20)

==================================================================
# 13.2장 의사 결정 분기
1) doPlot이 1인 경우에만 플로팅을 위한 4-7번 라인의 코드가 실행되도록 스크립트를 수정하세요.
if doPlot == 1
    plot(density)
    title("Sample Densities")
    xticklabels(element)
    ylabel("Density (g/cm^3)")
end

2) if 조건이 충족되지 않는 경우 다음 코드 라인이 실행되도록 스크립트를 수정하세요.
disp("The density of " + element ...
    + " is " + density)

if doPlot == 1
    plot(density)
    title("Sample Densities")
    xticklabels(element)
    ylabel("Density (g/cm^3)")
else
    disp("The density of " + element ...
        + " is " + density)
end

추가실습) if 뒤에 elseif 키워드를 사용하여 조건을 추가할 수 있습니다.
여러 개의 elseif 블록을 포함할 수 있습니다.
변수 doDisplay를 추가하여 density 표시 여부를 전환해 보세요.
elseif 블록을 사용하여 이 조건을 추가해 보세요.

doDisplay = 0		% 확실하지 않음
if doDisplay == 1
    plot(density)
elseif doDisplay == 0
    density
end

--------------------------------------------------------------------------------------------------------------------
# 13.3장 for 루프
1) 코드가 7번 실행되도록 라이브 스크립트의 두 번째 섹션(4~7번 라인)에 있는 코드를 루프로 감싸세요. 루프 카운터의 이름을 idx로 지정하세요. 루프를 처음 실행할 때 idx의 값은 1이 되고 매 반복마다 1씩 증가합니다.
for idx = 1:7
    hold on
    plot(idx,density(idx),'*')
    hold off
    pause(0.2)
end

추가실습) 플롯이 움직이는 걸 보셨나요? 코드 pause(0.2)를 실행하면 플롯이 업데이트되도록 0.2초 동안 루프가 중지됩니다. 값 0.2를 증가시켜 애니메이션 시간을 늘려 보세요.
density 벡터의 요소가 7개이므로 루프는 7번 실행됩니다.
길이를 알 수 없는 벡터를 사용해 루프를 실행하려는 경우 length 함수를 대신 사용할 수 있습니다.
for idx = 1:length(density)
    hold on
    plot(idx,density(idx),'*')
    hold off
    pause(0.5)
end

==================================================================
# 14.1장 프로젝트 - 별의 운동
1) 기록된 스펙트럼의 마지막 파장 값을 포함하는 변수 lambdaEnd(λend)를 만드세요.
수식 λstart+(nObs−1)λdelta를 사용하여 lambdaEnd를 계산할 수 있습니다.
lambdaEnd를 사용하여 스펙트럼에서 λstart부터 λend까지 스텝이 λdelta인
파장들을 포함하는 열 벡터 lambda(λ)를 만드세요.

lambdaEnd = lambdaStart + (nObs - 1) * lambdaDelta
lambda = (lambdaStart:lambdaDelta:lambdaEnd)'

2) spectra의 여섯 번째 열을 벡터 s로 추출하세요.
s = spectra(:, 6)

3) 두 축 모두에 로그 스케일을 사용하여 파장(lambda)의 함수로 스펙트럼(s)을 플로팅하세요.
점 마커(.)를 사용하고 실선(-)으로 점을 연결하세요.
x 레이블 "Wavelength"와 y 레이블 "Intensity"를 플롯에 추가하세요.

loglog(lambda, s, ".-")
xlabel("Wavelength")
ylabel("Intensity")

4) s의 최솟값과 최솟값이 발생한 인덱스를 각각 포함하는 두 개의 변수 sHa와 idx를 만드세요.
idx를 사용하여 lambda의 요소를 참조해 알파 수소(Hydrogen-alpha) 선의 파장을 구하세요.
결과를 lambdaHa(λHa)로 저장하세요.

[sHa, idx] = min(s)
lambdaHa = lambda(idx)

5) x = lambdaHa, y = sHa를 마커 크기("MarkerSize")가 8인
빨간색 정사각형("rs")으로 플로팅하여 점을 기존 그래프에 추가하세요.
hold on
plot(lambdaHa, sHa, "rs", "MarkerSize", 8)

6) 적색편이 인자와 별이 지구로부터 멀어지는 속도(단위: km/s)를 계산하세요.
적색편이 인자를 변수 z에 할당하고 속도를 변수 speed에 할당하세요.
별의 알파 수소 파장을 사용하면 수식 z=(λHa/656.28)−1을 사용하여 적색편이 인자(지구에 상대적인 별의 속도)를 계산할 수 있습니다. 그러면 적색편이 인자를 빛의 속도(299792.458km/s)와 곱하여 속도를 계산할 수 있습니다.

z = (lambdaHa / 656.28) - 1
speed = z * 299792.458

7) spectra에서 여섯 번째 별 대신 두 번째 별에 대한 적색편이를 계산하도록
스크립트의 작업 2 및 7 섹션을 수정하세요.
s = spectra(:, 2)

추가실습) 인덱스 값을 변경하는 대신 슬라이더를 사용하여 spectra에서 임의의 열을 선택해 보세요.
슬라이더를 추가한 후 마우스 오른쪽 버튼으로 클릭하여 슬라이더 값을 구성하면 됩니다.
값이 spectra의 각 열을 거쳐야 합니다. 즉, 값을 1:1:10으로 구현해야 합니다.
-> 상단의 도구모음 - 코드 탭 - 컨트롤 - 숫자 슬라이더 - 최대/최소/간격 설정 - 출력창에서 수정클릭
s = spectra(:, 6)*2

--------------------------------------------------------------------------------------------------------------------
# 14.2장 프로젝트 – 별의 운동 II
1) 스크립트의 2번 라인을 수정하세요. 모든 별의 속도를 계산하도록 (:,2)를 삭제하세요.
[sHa,idx] = min(spectra);
lambdaHa = lambda(idx);
z = lambdaHa/656.28 - 1;
speed = z*299792.458

2) 루프 인덱스가 c인 for 루프를 만드세요. 루프 인덱스는 spectra의 모든 열(1~7)을 거쳐야 합니다.
루프 본문에서 spectra의 c번째 열을 s라는 이름의 변수로 추출하세요.
for c = 1:7
    s = spectra(:, c)
end

3) if 문을 for 루프 본문에 추가하세요. speed(c)가 0보다 작거나 같을 경우 파선(--)을 사용하여 lambda에 대한 s의 loglog 플롯을 만드세요.
하나의 플롯만 생성되도록 if 문 뒤에 hold on 명령을 추가하세요.
for c = 1:7
    s = spectra(:, c)
    if speed(c) <= 0
        hold on
        loglog(lambda, s, "--")
    end
end

4) else 문을 추가하세요. speed(c)가 0보다 클 경우 선 너비를 3으로 지정하여 lambda에 대한 s의 loglog 플롯을 만드세요. for 루프가 완료된 후 hold off를 입력하세요.
for c = 1:7
    s = spectra(:, c)
    if speed(c) <= 0
        hold on
        loglog(lambda, s, "--")
    else
        loglog(lambda, s, "LineWidth", 3)
    end
end
hold off

5) 배열 starnames를 사용하여 플롯에 범례를 추가하세요.
legend(starnames)

6) 0보다 큰 speed의 요소들과 같은 위치에 있는
starnames의 요소들을 포함하는 변수 movaway를 만드세요.
movaway = starnames(speed > 0)

추가실습) 완료하셨습니다!
다음 페이지에는 본 교육과정에서 설명한 모든 개념이 요약되어 있습니다.